#' Tessellation of plane by Tiles
#'
#' Tessellation is function to tiling euclidean plane by tiles.
#' @param tile is sf object that is generated by pattern function
#' @param n number of tiles in each tiling direction. In square tiling
#' in vertical and horizontal direction tile repeated n times.
#' @param type is type is tessellation. you can set "4-4" for square tiling
#' and "6-3" for hexagonal tiling.
#' @param box is boundary box that contains tile
#'
#' @return sf object
#' @export sf
#' @export dplyr
#'
#' @examples
#' # Square Tiling
#' tile <- pattern(theta = 45, delta = 0.5, polyLine = T)
#' tessellation(tile, n = 5)
#' s3 = sqrt(3)
#' # Hexagonal Tiling
#' hexagonal = rbind(c(-1,0), c(1,0), c(2,s3), c(1,2*s3), c(-1,2*s3),c(-2,s3),c(-1,0))
#' tile <- pattern(theta = 60, n = 6, delta = 0.2,
#'                 start_points = c(0,0), box = hexagonal, dist = 0.05, polyLine = F)
#' tessellation(tile,n = 2, type = "6-3", box = hexagonal)
tessellation <- function(tile, n, type = "4-4", shift = NULL,
                   box = rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))
                     ){
  suppressMessages(library(dplyr)) # TODO remove package
  suppressMessages(library(sf))

  pl_box = st_polygon(list(box)) %>% st_sfc()
  # Compute Center
  center = pl_box %>% st_centroid()

  # Compute Diameter
  if(is.null(shift)){
    ln <- st_linestring(box[1:2,])
    shift <- st_distance(ln,center) %>% as.vector()
  }


############################################################
#                                                          #
#                     Triangale tiling                     #
#                                                          #
############################################################
  if(type == "3-6"){
    cp = unclass(center)

  tiling <- tile
  for(i in 1:n) {

    vs1 = c(0,-1)*(-1)^(i-1)
    vs2 = c(cos(pi/6),sin(pi/6))*(-1)^(i-1)
    vs3 = c(-cos(pi/6),sin(pi/6))*(-1)^(i-1)

    reverseTile <- dplyr::mutate(tiling, geometry = (geometry-cp)*rotation(180)+cp)

    tiling = rbind(
      tiling,
      dplyr::mutate(reverseTile, geometry = geometry + 2^(i)*shift  * vs1),
      dplyr::mutate(reverseTile, geometry = geometry + 2^(i)*shift  * vs2),
      dplyr::mutate(reverseTile, geometry = geometry + 2^(i)*shift  * vs3)
    )
  }
  }

############################################################
#                                                          #
#                      Square Tiling                       #
#                                                          #
############################################################

  if(type == "4-4"){
    # Compute Center
    vs1 = c(0,1)
    vs2 = c(1,0)
    for(i in 0:(n-1)) {
      for(j in 0:(n-1)){
        if(i == 0 & j == 0){
          tiling <- tile
        } else{
          tiling = rbind(
            tiling,
            dplyr::mutate(tile,geometry = geometry + 2*(i*shift * vs1 + j*shift*vs2))
          )
        }
      }
    }
  }

############################################################
#                                                          #
#                     Hexagonal Tiling                     #
#                                                          #
############################################################

  if(type == "6-3"){
    # Compute Center
    vs1 = c(0,-1)
    vs2 = c(cos(-pi/6),sin(-pi/6))
    vs3 = c(cos(pi/6),sin(pi/6))

    for(i in 0:(n-1)) {
      for(j in 0:(n-1)){
        for (k in 0:(n-1)){
          if(i == 0 & j == 0 && k ==0){
            tiling <- tile
          } else{
            tiling = rbind(
              tiling,
              dplyr::mutate(tile,geometry = geometry + 2*(i*shift * vs1 + j*shift*vs2 + k*shift*vs3)))
        }
        }
      }
    }
  }

  return(tiling)
}
