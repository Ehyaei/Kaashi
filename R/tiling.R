#' Tiling of plane by Tiles
#'
#' Tiling is function to tiling euclidean plane by tiles.
#' @param tile is sf object that is generated by pattern function
#' @param n number of tiles in each tiling direction. In square tiling
#' in vertical and horizontal direction tile repeated n times.
#' @param type is type is tiling. you can set "square" for square tiling
#' , "hexagonal" for hexagonal tiling.
#' @param overlap is a Boolean variable that removes the boundary between polygons if it is TRUE.
#' @param box is boundary box that contains tile
#'
#' @return sf object
#' @export sf
#' @export dplyr
#'
#' @examples
#' # Square Tiling
#' library(ggplot2)
#' tile <- motif(theta = 45, delta = 0.5, polyLine = T)
#' tiles <- tiling(tile, n = 5)
#' tilePlotter(tiles)
#' s3 = sqrt(3)
#' # Hexagonal Tiling
#' hexagonal = rbind(c(-1,0), c(1,0), c(2,s3), c(1,2*s3), c(-1,2*s3),c(-2,s3),c(-1,0))
#' tile <- motif(theta = 60, n = 6, delta = 0.2,
#'                  box = hexagonal, dist = 0.05, polyLine = F)
#' tiles <- tiling(tile,n = 2, type = "hexagonal", box = hexagonal)
#' tilePlotter(tiles)
tiling <- function(tile, n, type = "square", shift = NULL, vector = NULL, overlap = FALSE,
                   box = rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))
                     ){
  suppressMessages(library(dplyr)) # TODO remove package
  suppressMessages(library(sf))

  if(overlap){
    ovd = 0.000001
    } else{
    ovd = 0
    }

  pl_box = st_polygon(list(box)) %>% st_sfc()
  # Compute Center
  center = pl_box %>% st_centroid()

  # Compute Diameter
  if(is.null(shift)){
    ln <- st_linestring(box[1:2,])
    shift <- st_distance(ln,center) %>% as.vector()
  }


############################################################
#                                                          #
#                     Periodic Tiling                      #
#                                                          #
############################################################

  if(type == "periodic"){
    for(i in 0:(n-1)) {
      for(j in 0:(n-1)){
        if(i == 0 & j == 0){
          tiling <- tile
        } else{
          tiling = rbind(
            tiling,
            dplyr::mutate(tile,geometry = geometry + i* (vector[1,] - ovd) + j*(vector[2,] - ovd))
          )
        }
      }
    }
    }
############################################################
#                                                          #
#                     Triangle Tiling                     #
#                                                          #
############################################################
  if(type == "triangle"){
    cp = unclass(center)

  tiling <- tile
  for(i in 1:n) {

    vs1 = c(0,-1)*(-1)^(i-1) - ovd
    vs2 = c(cos(pi/6),sin(pi/6))*(-1)^(i-1) - ovd
    vs3 = c(-cos(pi/6),sin(pi/6))*(-1)^(i-1) - ovd

    reverseTile <- dplyr::mutate(tiling, geometry = (geometry-cp)*rotation(180)+cp)

    tiling = rbind(
      tiling,
      dplyr::mutate(reverseTile, geometry = geometry + 2^(i)*shift  * vs1),
      dplyr::mutate(reverseTile, geometry = geometry + 2^(i)*shift  * vs2),
      dplyr::mutate(reverseTile, geometry = geometry + 2^(i)*shift  * vs3)
    )
  }
  }

############################################################
#                                                          #
#                      Square Tiling                       #
#                                                          #
############################################################

  if(type == "square"){
    # Compute Center
    vs1 = c(0,1) - ovd
    vs2 = c(1,0) - ovd
    for(i in 0:(n-1)) {
      for(j in 0:(n-1)){
        if(i == 0 & j == 0){
          tiling <- tile
        } else{
          tiling = rbind(
            tiling,
            dplyr::mutate(tile,geometry = geometry + 2*(i*shift * vs1 + j*shift*vs2))
          )
        }
      }
    }
  }

############################################################
#                                                          #
#                     Hexagonal Tiling                     #
#                                                          #
############################################################

  if(type == "hexagonal"){
    # Compute Center
    vs1 = c(0,-1) - ovd
    vs2 = c(cos(-pi/6),sin(-pi/6)) - ovd
    vs3 = c(cos(pi/6),sin(pi/6)) - ovd

    for(i in 0:(n-1)) {
      for(j in 0:(n-1)){
        for (k in 0:(n-1)){
          if(i == 0 & j == 0 && k ==0){
            tiling <- tile
          } else{
            tiling = rbind(
              tiling,
              dplyr::mutate(tile,geometry = geometry + 2*(i*shift * vs1 + j*shift*vs2 + k*shift*vs3)))
        }
        }
      }
    }
  }

  return(tiling)
}
